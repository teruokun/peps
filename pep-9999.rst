PEP: 9999
Title: Including Software Bill of Materials in Wheels
Author: Jeff Edwards <jeffe@amazon.com>
        Dustin Ingram <di@python.org>
Sponsor: Brett Cannon <brett at python.org>
PEP-Delegate: TBD
Discussions-To: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 03-May-2022


Abstract
========

This is a specification for the method for optional inclusion of one or more
Software Bill of Materials (SBOMs) into wheel distributions to offer more
thorough provenance tracking which notably would allow for attestations about
the source used to build the artifacts.


Motivation
==========

One of the many hurdles towards building a more secure software supply chain is
a lack of standardized metadata about the sources used to both build and test
an installable artifact. This is especially problematic for wheels including
but not limited to:

* Projects that build binary extensions (e.g. C/Rust extensions)

* Projects that vendor software from outside the Python ecosystem (e.g.
  ``numpy`` includes ``libgfortran``, ``cryptography`` includes ``openssl`` and
  Rust projects)

* Projects that vendor other Python projects for stability, portability, and/or
  reproducibility (e.g. ``setuptools`` includes a vendored copy of ``packaging``)

In all of these cases, while a wheel already includes a manifest and checksums
of the installable artifacts, it does not have a representation of the
authoritative sources for those artifacts, losing any authoritative context
around vendored Python projects and completely obfuscating the sources used for
native binaries. This lack of standardized transparency becomes clear once a
risk or vulnerability is found for a vendored dependency, where the lack of
transparency makes it difficult if not impossible to know if your software is
transitively vulnerable as a result.

A Software Bill of Materials (SBOM) describes a type of metadata format to
record these missing annotations in order to bridge this gap. The goals of
this PEP are:

#. To codify where and how SBOMs should be included within a Wheel to ensure a
   consistent lookup for consumers

#. To define a location and default SBOM format -- SPDX 2, JSON format -- to
   centralize ecosystem efforts around generating, ingesting, and verifying an
   artifact's SBOM within the ecosystem.


Rationale
=========

Why is this limited to wheels?
------------------------------

Wheels are the current standard for pre-built artifacts, where all dependencies
are either left to the installer of the wheel to resolve, download and install
or are already included within the wheel itself.

Source distributions are specifically not included since they may use an
arbitrary build system and build script which can download, install, and
subsequently vendor artifacts from other projects in a non-deterministic way,
so any SBOM included could not be reliably complete without additional
measures.


Why does the SBOM not include external dependencies?
----------------------------------------------------

Because wheels are used to distribute libraries, not applications, their
external dependencies (e.g. dependencies on other Python projects that would be
installed alongside the wheel at install time) are loosely specified. Due to
this, the actual artifacts installed at install time may vary based on a number
of factors, including but not limited to the Python version in use, the
platform, CPU architecture, the availability of the external artifacts, and
more.

An SBOM, however, represents a strict set of software that is guaranteed to be
included in the artifact, and thus will be present in the environment which the
wheel is installed into.


Why support multiple SBOM specifications?
-----------------------------------------

Specifications for this type of metadata may be superceded in the future and
specific industries may have restrictions or requirements where our choice may
not fully cover their requirements or existing SBOM infrastructure. Giving an
extensible way to include SBOMs allows for both internal and external
repositories to cater to those specific needs without customized logic and for
changes to the intended default to not hard-require the ecosystem to migrate
simultaneously.

Why should we recommend a default?
----------------------------------

Unifying expectations around generation, consumption, and verification of the
relevant SBOM help limit the initial scope of the necessary support and tools
written to fill these needs. This focuses the effort around a single target and
accelerates development while establishing a common practice.

Why SPDX 2?
-----------

Many factors were considered when choosing the specification including its
status in the open source community, governance, breadth of supported
use-cases, established history of maintainability, and these same factors for
any specifications it includes by default. SPDX 2 had the largest set of
features and annotations with a clear specification with a long history as well
as existing tooling.

Why JSON?
---------

JSON has a performant standard-library implementation and remains an standard
of near-universal interoperability between languages.

Specification
=============

This adds an optional ``sboms`` directory into the existing
``<distribution_identifier>.dist-info`` subdirectory within the wheel where
SBOMS can be found generically, with the current common standard location
defined for `SPDX version 2.* - JSON format
<https://spdx.github.io/spdx-spec/>`_t  located at ``spdx-2.json``. Example
destination:

``myproject-0.1.0.dist-info/sboms/spdx-2.json``


Backwards Compatibility
=======================

SBOM metadata is an optional component and therefore may be omitted. Any hard
requirement on including an SBOM or a specific SBOM type in a wheel is left to
repository owners to enforce and manage.


Security Implications
=====================

If an SBOM intentionally is added that intentionally take significantly longer
to read or verify, it could impact any consumers who are verifying SBOMs on
ingestion. Similarly, if PyPI ever moves to verifying the SBOM of a wheel
(whether synchronously or asynchronously), that process could also similarly be
vulnerable depending on the parsing and validation logic. However, given this
is fully optional, these risks aren't substantively greater than the addition
of other types of parse-able metadata.


How to Teach This
=================

While the metadata for a wheel can specify which *external* dependencies
should be installed alongside the wheel in order for it to function properly,
it contains no information about the source of the software contained *within*
the wheel. In the simplest case, the software in the wheel directly corresponds
to source in a public source repository.

Unfortunately, this is a simplistic representation of what a wheel may actually
contain. The usefulness of the wheel format derives from it's ability to
provide 'built' platform-native code alongside Python code, but it provides no
mechanism for identifying what that code is, where it came from, or what it was
'built' with.

Additionally, a project may choose to include sub-dependencies directly in it's
source (known as vendoring) rather than specify them to be installed alongside
the wheel at install-time. This means that these dependencies are only
available to the software within the wheel, but also that there is nothing
intrinsic about the wheel, it's metadata, or it's build process that describes
where this software came from.

Using SBOMs provides a means for recording the source of these types of
external dependencies often included in wheels. Including an SBOM in a wheel
allows this record to live alongside the software it describes.


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g.
proof-of-concept.]


Rejected Ideas
==============

Separated metadata specifier ``sboms/_index_.json``
---------------------------------------------------
This is the most reasonable alternate implementation, but it does require any
readers and writers to understand a separate metadata file format and defining
and maintaining a necessary expected field list for those records instead of
relying upon official standardized locations. In the interest of simplicity,
this chooses to standardize the expected locations instead of having metadata
about metadata.


Open Issues
===========

[Any points that are still being decided/discussed.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline
hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
