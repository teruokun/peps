PEP: 9999

Title: Software Bills of Materials for the Simple Repository API
Author: Jeff Edwards <jeffe@amazon.com>, Dustin Ingram <di@python.org>
Sponsor: Brett Cannon <brett at python.org>
PEP-Delegate: TBD
Discussions-To: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 03-May-2022


Abstract
========

This is a specification for presenting and serving one or more optional
software bill of materials (SBOMs) for a given artifact record in the
`PEP-503 <https://peps.python.org/pep-0503>` "simple" repository API.


Motivation
==========

One of the many hurdles towards building a more secure software supply chain is
a lack of standardized programming-language-agnostic metadata that describes
the both the contents of a distribution and, for packages bundling or vendoring
dependencies, attestations about those internal dependencies.  Examples 
where there is a notable gap in knowledge:

-  Projects that statically build binary extensions which include
   external projects (e.g. C/Rust extensions)

-  Projects that vendor software from outside the Python ecosystem (e.g.
   ``numpy`` includes ``libgfortran``, ``cryptography`` includes ``openssl``)

-  Projects that vendor other Python projects for stability, portability,
   and/or reproducibility (e.g. ``setuptools`` includes a vendored copy of
   ``packaging`` as well as other separately-maintained packages)

While the completeness of such metadata cannot be guaranteed to be accurate
as much of the metadata is likely to be attested to by the build process
itself which could arbitrarily omit relevant external references, it does
provide an ability to both verify the contents and, alongside the usage of a
signing mechanism such as SigStore, allow for significantly more fidelity 
when assessing the provenance and supply chain.

For example, this would allow for ``cryptography`` to include metadata about 
both the Rust Packages and sources alongside the specific version of OpenSSL
that is bundled into its binary wheels.  If a vulnerability is found in one of
these bundled packages, both ``cryptography`` and its consumers are then able 
to identify if they could potentially be transitively vulnerable.


Rationale
=========

Why support multiple SBOM specifications?
-----------------------------------------

Specifications for this type of metadata may be superceded in the future and
specific industries may have restrictions or requirements where our choice may
not fully cover their requirements or existing SBOM infrastructure. Giving an
extensible way to include SBOMs allows for both internal and external
repositories to cater to those specific needs without customized logic and for
changes to the intended default to not hard-require the ecosystem to migrate
simultaneously.


Why should this be in Simple Repositories?
------------------------------------------

Signing mechanisms such as SigStore require an authoritative URL of record for
any signed artifact.  Similar to `PEP-658 <https://peps.python.org/pep-0658>`,
it describes metadata about the artifact itself and so for readability and
simplicity, they are predefined suffixes on the artifact link itself.


Why does an SBOM not include external dependencies?
----------------------------------------------------

Because wheels are used to distribute libraries, not applications, their
external dependencies (e.g. dependencies on other Python projects that would be
installed alongside the wheel at install time) are loosely specified. Due to
this, the actual artifacts installed at install time may vary based on a number
of factors, including but not limited to the Python version in use, the
platform, CPU architecture, the availability of the external artifacts, and
more.

An SBOM, however, represents a strict set of software that is guaranteed to be
included in the artifact, and thus will be present in the environment which the
wheel is installed into.


Specification
==============

This add a new optional attribute for artifact anchor tags `data-sboms` which
is defined as a comma-separated list of 
`normalized <https://peps.python.org/pep-0503/#normalized-names>` available
SBOM ``<specification>.<format>`` for the artifact.  The relevant SBOM for each member of the listed
is found at ``<artifact>.sbom.<specification>.<format>``.

The following SBOM specification formats are predefined as examples:

- cyclonedx.json
- cyclonedx.xml
- spdx2.yaml
- spdx2.json
- spdx2.rdf


Security Implications
=====================

If an SBOM intentionally is added that intentionally take significantly longer
to read or verify, it could impact any consumers who are verifying SBOMs on
ingestion. Similarly, if PyPI ever moves to verifying the SBOM of a wheel
(whether synchronously or asynchronously), that process could also similarly be
vulnerable depending on the parsing and validation logic. However, given this is
fully optional, these risks aren't substantively greater than the addition of
other types of parse-able metadata.


How to Teach This
=================

While the metadata for a wheel can specify which *external* dependencies should
be installed alongside the wheel in order for it to function properly, it
contains no information about the source of the software contained *within* the
wheel. In the simplest case, the software in the wheel directly corresponds to
source in a public source repository.

Unfortunately, this is a simplistic representation of what a wheel may actually
contain. The usefulness of the wheel format derives from it's ability to provide
'built' platform-native code alongside Python code, but it provides no mechanism
for identifying what that code is, where it came from, or what it was 'built'
with.

Additionally, a project may choose to include sub-dependencies directly in it's
source (known as vendoring) rather than specify them to be installed alongside
the wheel at install-time. This means that these dependencies are only available
to the software within the wheel, but also that there is nothing intrinsic about
the wheel, it's metadata, or it's build process that describes where this
software came from.

Using SBOMs provides a means for recording the source of these types of external
dependencies for both Wheels and source distributions and storing them alongside
the artifacts 


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g.
proof-of-concept.]


Rejected Ideas
==============

Including the SBOMs in the artifacts themselves
-----------------------------------------------

SBOMs are a record to support provenance tracking systems with more details
about an artifact, both of which may or may not be signed by the author and/or
build-provider.  However because most SBOM formats require completeness in
the form of a full and verifiable manifest (usually in the form of a hash
tree), they require a special flag to signify the SBOM themself to keep from
requiring a separate hash of its own contents from causing a circular
hashing issue (i.e. including the hash of for itself will change the hash of
its contents).  As such, if SBOMs are produced in multiple formats for the same
artifact, then including both within the artifact only adds additional areas
for collision and complexity.  

In addition, SBOMs can be verbose, potentially containing a large number of
attestations and records for a package whos resulting artifact is quite small.
For example, a package that utilizes an existing Rust framework may need to
annotate between 10-100+ entries for all of the Rust packages brought in and
compiled, even if the resulting stripped binary is notably small.  Keeping the 
SBOMs in their own separate resources allows it to be decoupled from
downloading the necessary artifact, allowing for a cleaner separation of
concerns for package managers and security processes.


Open Issues
===========

**Up for discussion**

[Any points that are still being decided/discussed.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline
hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
